using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;
using KModkit;

public class LegacyTetherScript : MonoBehaviour
{
	public KMAudio Audio;
    public KMBombInfo Bomb;
	public KMBombModule Module;
	
	public KMSelectable[] Tiles;
	public AudioSource MusicPlayer;
	public AudioClip[] SFX;
	
	List<int[]> TetherRange = new List<int[]>();
	List<int[]> NumberAddition = new List<int[]>();
	int[] NumberBasis = new int[16];
	int[] PressAmount = new int[16];
	string[] CoordinatesCodename = {"A1", "B1", "C1", "D1", "A2", "B2", "C2", "D2", "A3", "B3", "C3", "D3", "A4", "B4", "C4", "D4"};
	bool Interactable = true;
	
	//Logging
    static int moduleIdCounter = 1;
    int moduleId;
    private bool ModuleSolved;
	
	void Awake()
	{
		moduleId = moduleIdCounter++;
		for (int i = 0; i < 16; i++)
		{
			int Tile = i;
			Tiles[i].OnInteract += delegate
			{
				PressTile(Tile);
				return false; 
			};
		}
	}
	
	void Start()
	{
		int BaseNumber = UnityEngine.Random.Range(0,10);
		for (int x = 0; x < NumberBasis.Length; x++)
		{
			NumberBasis[x] = BaseNumber;
			PressAmount[x] = 0;
			int TetherAmount = UnityEngine.Random.Range(7,10);
			int[] NumberShuffle = Enumerable.Range(0,16).ToArray().Shuffle();
			List<int> TempNumberList = new List<int>();
			List<int> TempNumberAdditionList = new List<int>();
			for (int y = 0; y < TetherAmount; y++)
			{
				TempNumberList.Add(NumberShuffle[y]);
				TempNumberAdditionList.Add(UnityEngine.Random.Range(1,10));
			}
			TetherRange.Add(TempNumberList.ToArray());
			NumberAddition.Add(TempNumberAdditionList.ToArray());
		}
		
		for (int x = 0; x < 10000; x++)
		{
			int NumberPickTest = UnityEngine.Random.Range(0,16);
			PressAmount[NumberPickTest] = (PressAmount[NumberPickTest] + 1) % 10;
		}
		
		int NumberOfSteps = 0;
		for (int x = 0; x < PressAmount.Length; x++)
		{
			NumberOfSteps += PressAmount[x];
		}
		
		while (NumberOfSteps < 50)
		{
			int NumberPick = -1;
			do
			{
				NumberPick = UnityEngine.Random.Range(0,16);
			}
			while (PressAmount[NumberPick].EqualsAny(Enumerable.Range(0,10)));
			PressAmount[NumberPick]++;
		}
		
		for (int x = 0; x < PressAmount.Length; x++)
		{
			for (int y = 0; y < PressAmount[x]; y++)
			{
				for (int z = 0; z < TetherRange[x].Length; z++)
				{
					NumberBasis[TetherRange[x][z]] = (NumberBasis[TetherRange[x][z]] + (NumberAddition[x][z] * 9)) % 10;
				}
			}
		}
		
		/*int AmountOfSteps = UnityEngine.Random.Range(40,61);
		for (int a = 0; a < AmountOfSteps; a++)
		{
			int NumberPick = -1;
			do
			{
				NumberPick = UnityEngine.Random.Range(0,16);
			}
			while (PressAmount[NumberPick].EqualsAny(Enumerable.Range(0,10)));
			PressAmount[NumberPick]++;
			for (int x = 0; x < TetherRange[NumberPick].Length; x++)
			{
				NumberBasis[TetherRange[NumberPick][x]] = (NumberBasis[TetherRange[NumberPick][x]] + (NumberAddition[NumberPick][x] * 9)) % 10;
			}
		}*/
		
		for (int x = 0; x < NumberBasis.Length; x++)
		{
			Tiles[x].GetComponentInChildren<TextMesh>().text = NumberBasis[x].ToString();
		}
		
		Debug.LogFormat("[Tether #{0}] The grid generated by the module: ", moduleId);
		string Grid = "";
		for (int x = 0; x < Tiles.Length; x++)
		{
			Grid += Tiles[x].GetComponentInChildren<TextMesh>().text;
			if (x % 4 == 3)
			{
				Debug.LogFormat("[Tether #{0}] {1}", moduleId, Grid);
				Grid = "";
			}
		}
		
		string DebugString2 = "";
		for (int x = 0; x < NumberBasis.Length; x++)
		{
			string DebugString = "";
			for (int y = 0; y < TetherRange[x].Length; y++)
			{
				DebugString = DebugString + CoordinatesCodename[TetherRange[x][y]] + ":+" + NumberAddition[x][y].ToString() + (y < TetherRange[x].Length - 1 ? ", " : "");
			}
			Debug.LogFormat("[Tether #{0}] The tile numbers that changes when you press {1} are: {2}", moduleId, CoordinatesCodename[x], DebugString);
			DebugString2 = DebugString2 + CoordinatesCodename[x] + ": " + PressAmount[x].ToString() + (x < NumberBasis.Length - 1 ? ", " : "");
		}
		Debug.LogFormat("[Tether #{0}] The amount of times that each tiles should be pressed (based on my algorithm) are: {1}", moduleId, DebugString2);
	}
	
	void PressTile(int Tile)
	{
		Tiles[Tile].AddInteractionPunch(0.2f);
		if (!ModuleSolved && Interactable)
		{
			Audio.PlaySoundAtTransform(SFX[0].name, transform);
			for (int z = 0; z < TetherRange[Tile].Length; z++)
			{
				NumberBasis[TetherRange[Tile][z]] = (NumberBasis[TetherRange[Tile][z]] + (NumberAddition[Tile][z])) % 10;
			}
			
			for (int x = 0; x < NumberBasis.Length; x++)
			{
				Tiles[x].GetComponentInChildren<TextMesh>().color = x.EqualsAny(0,2,5,7,8,10,13,15) ? new Color32(0,0,0,255) : new Color32(255,0,0,255);
			}
			
			for (int x = 0; x < TetherRange[Tile].Length; x++)
			{
				Tiles[TetherRange[Tile][x]].GetComponentInChildren<TextMesh>().color = new Color32(255,255,255,255);
			}
			
			for (int x = 0; x < NumberBasis.Length; x++)
			{
				Tiles[x].GetComponentInChildren<TextMesh>().text = NumberBasis[x].ToString();
			}
			
			PressAmount[Tile] = ((PressAmount[Tile]-1) + 10) % 10;
			Debug.LogFormat("[Tether #{0}] The amount of times that {1} needs to be pressed has changed to: {2}", moduleId, CoordinatesCodename[Tile], PressAmount[Tile].ToString());
			
			int Comparer = 0;
			for (int x = 0; x < NumberBasis.Length; x++)
			{
				if (x == 0)
				{
					Comparer = NumberBasis[x];
				}
				
				else
				{
					if (NumberBasis[x] != Comparer)
					{
						return;
					}	
				}
			}
			Debug.LogFormat("[Tether #{0}] They have been unbounded. Module solved.", moduleId);
			Interactable = false;
			StartCoroutine(WillAllwaysHappen());
		}
	}
	
	IEnumerator WillAllwaysHappen()
	{
		for (int x = 0; x < NumberBasis.Length; x++)
		{
			Tiles[x].GetComponentInChildren<TextMesh>().color = x.EqualsAny(0,2,5,7,8,10,13,15) ? new Color32(0,0,0,255) : new Color32(255,0,0,255);
			Tiles[x].GetComponentInChildren<TextMesh>().text = "";
		}
		MusicPlayer.clip = SFX[2];
		MusicPlayer.Play();
		while (MusicPlayer.isPlaying)
		{
			 yield return new WaitForSecondsRealtime(0.01f);
		}
		ModuleSolved = true;
		Module.HandlePass();
		MusicPlayer.clip = SFX[1];
		MusicPlayer.Play();
		string[] TheVoidSpeaks = {"WE  WILLCOMEBACK", "THE VOIDWILLLIVE", "YOU WILLSEE SOON", "YOU HAVENOT WON ", "THISWILLNOT END ", "COMEAND JOINUS  ", "NO  ONE TO  HELP", "YOU DID THIS    ", "WE  SEE YOU     ", "YOU ARE NOT SAFE", "YOU WILLBE  BACK", "YOUREYESONLYLIE ", "YOU WILLFEARUS  ", "OUR TIMEWILLCOME", "YOURLIFEWILLEND ", "DO  NOT LOOKBACK", "NO  ONE IS  HERE", "THISIS  THE END "};
		int ChosenDestiny = UnityEngine.Random.Range(0,TheVoidSpeaks.Length);
		while (MusicPlayer.isPlaying)
		{
			for (int x = 0; x < 2; x++)
			{
				for (int y = 0; y < NumberBasis.Length; y++)
				{
					Tiles[y].GetComponentInChildren<TextMesh>().text = x == 0 ? TheVoidSpeaks[ChosenDestiny][y].ToString() : "";
				}
				yield return new WaitForSecondsRealtime(0.1f);
			}
		}
	}
	
	//twitch plays
    #pragma warning disable 414
    private readonly string TwitchHelpMessage = @"To press a certain coordinate on the module, use the command !{0} [A-D][1-4] (You can perform this action in a chain. Example: !{0} A1 B3 C4)";
    #pragma warning restore 414
	
    IEnumerator ProcessTwitchCommand(string command)
    {
		string[] parameters = command.Split(' ');
		for (int x = 0; x < parameters.Length; x++)
		{
			yield return null;
			if (!Interactable)
			{
				yield return "sendtochaterror You can not interact with the module currently. Command ignored.";
				yield break;
			}
			
			if (!parameters[x].ToUpper().EqualsAny(CoordinatesCodename))
			{
				yield return "sendtochaterror An invalid coordinate was detected. The command was not continued.";
				yield break;
			}
			yield return "solve";
			Tiles[Array.IndexOf(CoordinatesCodename, parameters[x].ToUpper())].OnInteract();
			yield return new WaitForSecondsRealtime(0.1f);
		}
	}

}
